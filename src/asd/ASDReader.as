//Generated by Prefab3D 2.143, Fri May 13 07:26:12 GMT-0500 2016. www.closier.nl/prefab
package asd
{
	//import away3d.core.base.Geometry;
	//import away3d.core.base.SubGeometry;
	import flash.utils.ByteArray;
	import flash.utils.Endian;

	public class ASDReader
	{
		private static const MAGIC:String = "ASD";
		private static var _revision:Number;
		
		private static var _indices:Vector.<uint>;
		private static var _vertices:Vector.<Number>;
		private static var _uvs:Vector.<Number>;
		private static var _secondaryUVs:Vector.<Number>;
		private static var _normals:Vector.<Number>;

		public static function validateHeader(ba:ByteArray):uint
		{
			ba.inflate();
			ba.endian = Endian.BIG_ENDIAN;
			ba.position = 0;
			var magic:String = ba.readUTFBytes(3);
			var v:Number = ba.readByte();
			_revision = ba.readByte();
			if(magic != MAGIC || v+_revision>2)
				throw new Error("Incorrect asd file. Use latest outputs from Prefab!");

			return ba.readUnsignedInt();
		}

		public static function decodeGeometry(ba:ByteArray):void
		{
			var filelen:uint = validateHeader(ba);
			var id:uint = ba.readUnsignedInt();
			var blockLen:Number = ba.readUnsignedInt();
			//var geom:Geometry = new Geometry();
			
			if (id == 0)
			{
				var subgCount:uint = ba.readUnsignedInt();
				//var subGeom:SubGeometry;
				var indices:Vector.<uint>;
				var vertices:Vector.<Number>;
				var uvs:Vector.<Number>;
				var secondaryUVs:Vector.<Number>;
				var normals:Vector.<Number>;
				
				for (var i:uint = 0; i < subgCount; ++i)
				{
					//subGeom = new SubGeometry();
					_indices = readUnsignedShort(ba);
					_vertices = readFloats(ba);
					_uvs = readFloats(ba);
					_normals = readFloats(ba);
					if (_revision > 0)
					{
						_secondaryUVs = readFloats(ba);
						//if(secondaryUVs && secondaryUVs.length == uvs.length) subGeom.updateSecondaryUVData(secondaryUVs);
					} 
					/*subGeom.updateVertexData(vertices);
					subGeom.updateIndexData(indices);
					subGeom.updateUVData(uvs);
					if(normals) subGeom.updateVertexNormalData(normals);
					
					geom.addSubGeometry(subGeom);*/	
				}
				
				/*trace("indices: " + _indices);
				trace("vertices: " + _vertices);
				trace("uvs: " + _uvs);
				trace("secondaryUVs: " + _secondaryUVs);
				trace("normals: " + _normals);*/
			} 
			else
			{
				abort();
			}
		}

		public static function decodeVector(ba:ByteArray):Vector.<Number>
		{
			var filelen:uint = validateHeader(ba);
			var id:uint = ba.readUnsignedInt();
			var blockLen:Number = ba.readUnsignedInt();
			var type:uint = ba.readUnsignedInt();
			var vn:Vector.<Number>;
			if(type == 0){
				vn = readFloats(ba);
			} else {
				abort();
			}
			
			return vn;
		}

		private static function abort():void
		{
			throw new Error("Incorrect asd file. Use latest outputs from Prefab!");
		}

		private static function readUnsignedShort(ba:ByteArray):Vector.<uint>
		{
			var len:uint = ba.readUnsignedInt()*.5;
			if(len<1) return null;
			var i:uint;
			var v:Vector.<uint> = new Vector.<uint>(len);
			while(i<len){
				v[i] = ba.readUnsignedShort();
				i++;
			}
			return v;
		}

		private static function readFloats(ba:ByteArray):Vector.<Number>
		{
			var len:uint = ba.readUnsignedInt()/4;
			if(len<1) return null;
			var i:uint = 0;
			var v:Vector.<Number> = new Vector.<Number>(len);
			while(i<len){
				v[i] = ba.readFloat();
				i++;
			}
			return v;
		}
		
		static public function get indices():Vector.<uint> 
		{
			return _indices;
		}
		
		static public function get vertices():Vector.<Number> 
		{
			return _vertices;
		}
		
		static public function get uvs():Vector.<Number> 
		{
			return _uvs;
		}
		
		static public function get secondaryUVs():Vector.<Number> 
		{
			return _secondaryUVs;
		}
		
		static public function get normals():Vector.<Number> 
		{
			return _normals;
		}

	}
}